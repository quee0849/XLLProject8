//// 
//// Autogenerated by xlw 
//// Do not edit this file, it will be overwritten 
//// by InterfaceGenerator 
////

#include "xlw/MyContainers.h"
#include <xlw/CellMatrix.h>
#include "joshiDemoFunctions.h"
#include <xlw/xlw.h>
#include <xlw/XlFunctionRegistration.h>
#include <stdexcept>
#include <xlw/XlOpenClose.h>
#include <xlw/HiResTimer.h>
using namespace xlw;

namespace {
const char* LibraryName = "MonteCarloRoutines";
};


// registrations start here


namespace
{
XLRegistration::Arg
EchoShortArgs[]=
{
{ "x"," number to be echoed ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoShort("xlEchoShort",
"EchoShort",
" echoes a short ",
LibraryName,
EchoShortArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoShort(
LPXLFOPER xa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper xb(
	(xa));
short x(
	xb.AsShort("x"));

short result(
	EchoShort(
		x)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
AddMatrixArgs[]=
{
{ "matrixA","too lazy to comment this one ","XLF_OPER"},
{ "matrixB","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerAddMatrix("xlAddMatrix",
"AddMatrix",
" adds two matrices together after checking they're the same size. ",
LibraryName,
AddMatrixArgs,
2
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlAddMatrix(
LPXLFOPER matrixAa,
LPXLFOPER matrixBa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper matrixAb(
	(matrixAa));
MyMatrix matrixA(
	matrixAb.AsMatrix("matrixA"));

XlfOper matrixBb(
	(matrixBa));
MyMatrix matrixB(
	matrixBb.AsMatrix("matrixB"));

MyMatrix result(
	AddMatrix(
		matrixA,
		matrixB)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
MCVanillaCallArgs[]=
{
{ "parametersMatrix","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerMCVanillaCall("xlMCVanillaCall",
"MCVanillaCall",
" Return the price of vanilla call given spot, strike, r, d, vol, expiry, numPaths ",
LibraryName,
MCVanillaCallArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlMCVanillaCall(
LPXLFOPER parametersMatrixa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper parametersMatrixb(
	(parametersMatrixa));
MyMatrix parametersMatrix(
	parametersMatrixb.AsMatrix("parametersMatrix"));

double result(
	MCVanillaCall(
		parametersMatrix)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
MCVanillaChoice3Args[]=
{
{ "parametersMatrix","too lazy to comment this one ","XLF_OPER"},
{ "seed","too lazy to comment this one ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerMCVanillaChoice3("xlMCVanillaChoice3",
"MCVanillaChoice3",
" Return the price, variance and std error of vanilla option given spot, r, d, vol, expiry, name, numPaths, Strike ",
LibraryName,
MCVanillaChoice3Args,
2
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlMCVanillaChoice3(
LPXLFOPER parametersMatrixa,
double seeda)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper parametersMatrixb(
	(parametersMatrixa));
CellMatrix parametersMatrix(
	parametersMatrixb.AsCellMatrix("parametersMatrix"));

unsigned long seed(
	static_cast<unsigned long>(seeda));

 HiResTimer t;
CellMatrix result(
	MCVanillaChoice3(
		parametersMatrix,
		seed)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
MCVanillaChoice1Args[]=
{
{ "parametersMatrix","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerMCVanillaChoice1("xlMCVanillaChoice1",
"MCVanillaChoice1",
" Return the price, variance and std error of vanilla option given spot, r, d, vol, expiry, name, numPaths, Strike ",
LibraryName,
MCVanillaChoice1Args,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlMCVanillaChoice1(
LPXLFOPER parametersMatrixa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper parametersMatrixb(
	(parametersMatrixa));
CellMatrix parametersMatrix(
	parametersMatrixb.AsCellMatrix("parametersMatrix"));

 HiResTimer t;
CellMatrix result(
	MCVanillaChoice1(
		parametersMatrix)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
MCVanillaChoiceConvergenceTableArgs[]=
{
{ "parametersMatrix","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerMCVanillaChoiceConvergenceTable("xlMCVanillaChoiceConvergenceTable",
"MCVanillaChoiceConvergenceTable",
" return convergence table for vanilla option given spot,  r, d, vol, expiry, name, numPaths, Strike ",
LibraryName,
MCVanillaChoiceConvergenceTableArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlMCVanillaChoiceConvergenceTable(
LPXLFOPER parametersMatrixa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper parametersMatrixb(
	(parametersMatrixa));
CellMatrix parametersMatrix(
	parametersMatrixb.AsCellMatrix("parametersMatrix"));

CellMatrix result(
	MCVanillaChoiceConvergenceTable(
		parametersMatrix)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
MCVanillaChoiceEulerSteppingArgs[]=
{
{ "parametersMatrix","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerMCVanillaChoiceEulerStepping("xlMCVanillaChoiceEulerStepping",
"MCVanillaChoiceEulerStepping",
" Return the price, variance and std error of vanilla option using Euler stepping engine given spot, r, d, vol, expiry, name, numPaths, numSteps, Strike ",
LibraryName,
MCVanillaChoiceEulerSteppingArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlMCVanillaChoiceEulerStepping(
LPXLFOPER parametersMatrixa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper parametersMatrixb(
	(parametersMatrixa));
CellMatrix parametersMatrix(
	parametersMatrixb.AsCellMatrix("parametersMatrix"));

 HiResTimer t;
CellMatrix result(
	MCVanillaChoiceEulerStepping(
		parametersMatrix)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
MCVanillaDeltaCallArgs[]=
{
{ "parametersMatrix","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerMCVanillaDeltaCall("xlMCVanillaDeltaCall",
"MCVanillaDeltaCall",
" Return the Delta of a vanilla call using pathwise method - make sure the string in the excel array is deltaCallPathwise ",
LibraryName,
MCVanillaDeltaCallArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlMCVanillaDeltaCall(
LPXLFOPER parametersMatrixa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper parametersMatrixb(
	(parametersMatrixa));
CellMatrix parametersMatrix(
	parametersMatrixb.AsCellMatrix("parametersMatrix"));

 HiResTimer t;
CellMatrix result(
	MCVanillaDeltaCall(
		parametersMatrix)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
MCVanillaDeltaLRArgs[]=
{
{ "parametersMatrix","too lazy to comment this one ","XLF_OPER"},
{ "seed","too lazy to comment this one ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerMCVanillaDeltaLR("xlMCVanillaDeltaLR",
"MCVanillaDeltaLR",
" Return the price, variance and std eke ",
LibraryName,
MCVanillaDeltaLRArgs,
2
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlMCVanillaDeltaLR(
LPXLFOPER parametersMatrixa,
double seeda)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper parametersMatrixb(
	(parametersMatrixa));
CellMatrix parametersMatrix(
	parametersMatrixb.AsCellMatrix("parametersMatrix"));

unsigned long seed(
	static_cast<unsigned long>(seeda));

 HiResTimer t;
CellMatrix result(
	MCVanillaDeltaLR(
		parametersMatrix,
		seed)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoOpen
//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoClose
//////////////////////////

